initially assume {
	eq vruntime1 c0() && eq vruntime2 c0();
}

always assume {
	gq c0() nice1() && gq c0() nice2() && gq c0() timeslice();
	!(lq vruntime1 vruntime2 && lq vruntime2 vruntime1);
	lq vruntime1 vruntime2 && ([vruntime1 <- add vruntime1 (times nice1() timeslice())] && [vruntime2 <- vruntime2] W lq vruntime2 vruntime1) -> F (lq vruntime2 vruntime1);
	lq vruntime2 vruntime1 && ([vruntime2 <- add vruntime2 (times nice2() timeslice())] && [vruntime1 <- vruntime1] W lq vruntime1 vruntime2) -> F (lq vruntime1 vruntime2);
}

always guarantee {
	[next <- idle] || [next <- task1] || [next <- task2];
	enqueue task1 -> F [next <- task1];
	enqueue task2 -> F [next <- task2];
	lq vruntime1 vruntime2 -> [next <- task1];
	lq vruntime2 vruntime1 -> [next <- task2];
	[next <- task1] -> [vruntime1 <- add vruntime1 (times nice1() timeslice())];
	[next <- task2] -> [vruntime2 <- add vruntime2 (times nice2() timeslice())];
}
