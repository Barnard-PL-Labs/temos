assume {
  (G (! (((eq num_tasks) c0()) && (! ((gte num_tasks) c0())))));
  (G ((((gte num_tasks) c0()) && [num_tasks <- ((add num_tasks) c1())]) -> (X ((gte num_tasks) c0()))));
  ((eq num_tasks) c0());
  (G ((enqueue task1) <-> (F (dequeue task1))));
  (G ((enqueue task2) <-> (F (dequeue task2))));
  (G (! (((enqueue task1) || (enqueue task2)) && ((dequeue task1) || (dequeue task2)))));
}

guarantee {
  (G (([next <- task1] || [next <- task2]) || [next <- idle]));
  (G ((enqueue task1) -> ([num_tasks <- ((inc num_tasks) c1())] && ([next <- task1] U (dequeue task1)))));
  (G ((enqueue task2) -> ([num_tasks <- ((inc num_tasks) c1())] && ([next <- task2] U (dequeue task2)))));
  (G ((dequeue task1) -> ([num_tasks <- ((sub num_tasks) c1())] && ((! [next <- task1]) W (enqueue task1)))));
  (G ((dequeue task2) -> ([num_tasks <- ((sub num_tasks) c1())] && ((! [next <- task2]) W (enqueue task2)))));
  (G ((gte num_tasks) c0()));
}
