/* AUTOMATICALLY GENERATED */
always assume{
/* !((gt vruntime1 vruntime2) && !(gt vruntime1 vruntime2)); */
/* !((gt vruntime2 vruntime1) && !(gt vruntime2 vruntime1)); */
/* (gt vruntime1 vruntime2) && ([vruntime1 <- ( add vruntime1 elapsed )] W (gt vruntime1 vruntime2)) -> F (gt vruntime1 vruntime2); */
/* (gt vruntime2 vruntime1) && ([vruntime2 <- ( add vruntime2 elapsed )] W (gt vruntime2 vruntime1)) -> F (gt vruntime2 vruntime1); */

!((gt vruntime1 vruntime2) && (gt vruntime2 vruntime1));
!(gt vruntime1 vruntime2) && ([vruntime1 <- ( add vruntime1 elapsed )] W (gt vruntime1 vruntime2)) -> F (gt vruntime1 vruntime2);
!(gt vruntime2 vruntime1) && ([vruntime2 <- ( add vruntime2 elapsed )] W (gt vruntime2 vruntime1)) -> F (gt vruntime2 vruntime1);

}

//#LIA#
/*
 * A preemptive kernel (scheduler) is one that can interrupt the current running task,
 * because a task with higher priority needs to run now.
 */
always assume {
	!(enqueue job1 && dequeue job1);
	!(enqueue job2 && dequeue job2);
	!(preempt job1 && preempt job2);
	!(enqueue job1 && preempt job1);
	!(enqueue job2 && preempt job2);
	gte elapsed c0();
}

always guarantee {
	[next <- job1] || [next <- job2] || [next <- idle];

	enqueue job1 -> ((F [next <- job1] && ([state1 <- runnable] W dequeue job1))  || F (dequeue job1 || preempt job1));
	enqueue job2 -> ((F [next <- job2] && ([state2 <- runnable] W dequeue job1))  || F (dequeue job2 || preempt job2));

	dequeue job1 -> ((![next <- job1] && ![state1 <- runnable]) W enqueue job1);
	dequeue job2 -> ((![next <- job2] && ![state2 <- runnable]) W enqueue job2);
	
	preempt job1 -> ![next <- job1];
	preempt job2 -> ![next <- job2];

	[next <- job1] <-> [vruntime1 <- add vruntime1 elapsed ];
	[next <- job2] <-> [vruntime2 <- add vruntime2 elapsed ];

	gt vruntime1 vruntime2 && [state2 <- runnable] -> [next <- job2];
	gt vruntime2 vruntime1 && [state1 <- runnable] -> [next <- job1];
}

