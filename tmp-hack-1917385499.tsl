always assume{
!((gt cpu0 cpu1) && !(gt cpu0 cpu1));
!((gt cpu0 cpu1) && (gt cpu1 cpu0));
!((gt cpu1 cpu0) && !(gt cpu1 cpu0));
(gt cpu0 cpu1) && ([cpu0 <- ( add cpu0 c1() )] W (gt cpu0 cpu1)) -> F (gt cpu0 cpu1);
(gt cpu0 cpu1) && ([cpu0 <- ( add cpu0 c1() )] W (gt cpu1 cpu0)) -> F (gt cpu1 cpu0);
(gt cpu1 cpu0) && ([cpu1 <- ( add cpu1 c1() )] W (gt cpu0 cpu1)) -> F (gt cpu0 cpu1);
(gt cpu1 cpu0) && ([cpu1 <- ( add cpu1 c1() )] W (gt cpu1 cpu0)) -> F (gt cpu1 cpu0);
!(gt cpu0 cpu1) && ([cpu0 <- ( add cpu0 c1() )] W (gt cpu0 cpu1)) -> F (gt cpu0 cpu1);
!(gt cpu0 cpu1) && ([cpu0 <- ( add cpu0 c1() )] W (gt cpu1 cpu0)) -> F (gt cpu1 cpu0);
!(gt cpu1 cpu0) && ([cpu1 <- ( add cpu1 c1() )] W (gt cpu0 cpu1)) -> F (gt cpu0 cpu1);
!(gt cpu1 cpu0) && ([cpu1 <- ( add cpu1 c1() )] W (gt cpu1 cpu0)) -> F (gt cpu1 cpu0);

}
//#LIA#
always guarantee {
	enqueue && gt cpu0 cpu1 -> [cpu0 <- add cpu0 c1()];
	enqueue && gt cpu1 cpu0 -> [cpu1 <- add cpu1 c1()];

	(!(enqueue) && gt cpu0 cpu1) -> [cpu0 <- add cpu0 c1()] && [cpu1 <- sub cpu1 c0()];
	(!(enqueue) && gt cpu1 cpu0) -> [cpu1 <- add cpu1 c1()] && [cpu0 <- sub cpu0 c0()];

	!(G gt cpu0 cpu1);
	!(G gt cpu1 cpu0);
}
