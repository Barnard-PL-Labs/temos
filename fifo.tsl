//#LIA#

always assume {
	[time1 <- now] && (([time1 <- time1] && [now <- add now c1()]) W [time2 <- now]) -> lte time1 time2;
	[time2 <- now] && (([time2 <- time2] && [now <- add now c1()]) W [time1 <- now]) -> lte time1 time2;
}

always assume {
	enqueue task1 -> !(enqueue task1) W dequeue task1;
	enqueue task2 -> !(enqueue task2) W dequeue task2;
	[time1 <- now] -> eq time1 now;
	[time2 <- now] -> eq time2 now;
}

always guarantee {
	[now <- add now c1()];
	enqueue task1 <-> [time1 <- now];
	enqueue task2 <-> [time2 <- now];

	enqueue job1 -> (F [next <- job1] && ([state1 <- runnable] W [next <- job1])
	enqueue job2 -> (F [next <- job2] && ([state2 <- runnable] W [next <- job2])

	[next <- task1] && [state2 <- runnable] ->   lte time1 time2;
	[next <- task2] && [state1 <- runnable] -> !(lte time1 time2);
}
