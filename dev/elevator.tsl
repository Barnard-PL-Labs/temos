//#LIA#
always assume {
	(eq floor c1() && [floor <- add floor c1()]) -> X (eq floor c2());
	(eq floor c2() && [floor <- add floor c1()]) -> X (eq floor c3());

	(eq floor c2() && [floor <- sub floor c1()]) -> X (eq floor c1());
	(eq floor c3() && [floor <- sub floor c1()]) -> X (eq floor c2());

	(eq floor c1() && [floor <- floor]) -> X (eq floor c1());
	(eq floor c2() && [floor <- floor]) -> X (eq floor c2());
	(eq floor c3() && [floor <- floor]) -> X (eq floor c3());

	(eq floor c1() || eq floor c2() || eq floor c3()) -> (lte c1() floor);

	(lte c1() floor && lte floor c3()) -> (eq floor c1() || eq floor c2() || eq floor c3());
}

assume {
	lte c1() floor;
	lte floor c3();
}

always guarantee {
	[floor <- floor] || [floor <- sub floor c1()] || [floor <- add floor c1()];
	lte c1() floor;
	F eq floor c1();
	F eq floor c2();
	F eq floor c3();
}
